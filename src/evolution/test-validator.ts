/**
 * Themis - Independent Test Validator
 * 
 * An independent agent that validates tests generated by Prometheus.
 * Prevents hallucination and ensures test quality.
 * 
 * Named after Themis, Greek goddess of divine law and order.
 */

import { RuntimeExecutor } from '../runtime/runtime-executor';

/**
 * Test validation result
 */
export type TestValidationResult = {
  /** Whether test is valid */
  isValid: boolean;
  /** Validation score (0-100) */
  score: number;
  /** Issues found */
  issues: TestIssue[];
  /** Recommendations */
  recommendations: string[];
  /** Validated by */
  validatedBy: 'themis';
  /** Validation timestamp */
  validatedAt: number;
};

/**
 * Test issue severity
 */
export type TestIssueSeverity = 'critical' | 'high' | 'medium' | 'low';

/**
 * Test issue
 */
export type TestIssue = {
  /** Issue type */
  type: TestIssueType;
  /** Severity */
  severity: TestIssueSeverity;
  /** Description */
  description: string;
  /** Location in test code */
  location?: {
    line: number;
    column: number;
  };
  /** Suggested fix */
  suggestedFix?: string;
};

/**
 * Test issue types
 */
export type TestIssueType =
  | 'hallucination'          // Test tests non-existent functionality
  | 'tautology'              // Test always passes (e.g., expect(true).toBe(true))
  | 'no_assertion'           // Test has no assertions
  | 'wrong_assertion'        // Assertion doesn't match function behavior
  | 'missing_edge_case'      // Important edge case not tested
  | 'flaky'                  // Test may be non-deterministic
  | 'too_broad'              // Test tests too many things
  | 'too_narrow'             // Test doesn't test enough
  | 'syntax_error'           // Test has syntax errors
  | 'import_error'           // Test imports non-existent modules
  | 'mock_hallucination';    // Test mocks non-existent dependencies

/**
 * Generated test to validate
 */
export type GeneratedTest = {
  /** Test code */
  code: string;
  /** Target function/module being tested */
  target: {
    /** File path */
    filePath: string;
    /** Function/class name */
    name: string;
    /** Function signature */
    signature?: string;
  };
  /** Test description */
  description: string;
  /** Generated by */
  generatedBy: 'prometheus';
  /** Generation timestamp */
  generatedAt: number;
};

/**
 * Themis - Independent Test Validator
 * 
 * Validates tests generated by Prometheus to prevent hallucination.
 * Uses a separate LLM context to avoid bias.
 */
export class TestValidator {
  constructor(private runtimeEngine: RuntimeExecutor) {}

  /**
   * Validate a generated test
   * 
   * Uses independent analysis to detect hallucinations and issues.
   * 
   * @param test - Generated test to validate
   * @param sourceCode - Source code being tested
   * @returns Validation result
   */
  async validateTest(
    test: GeneratedTest,
    sourceCode: string
  ): Promise<TestValidationResult> {
    const issues: TestIssue[] = [];

    // 1. Static analysis checks (fast, deterministic)
    const staticIssues = await this.performStaticAnalysis(test);
    issues.push(...staticIssues);

    // 2. Semantic validation (LLM-based, independent)
    const semanticIssues = await this.performSemanticValidation(test, sourceCode);
    issues.push(...semanticIssues);

    // 3. Hallucination detection (critical!)
    const hallucinationIssues = await this.detectHallucinations(test, sourceCode);
    issues.push(...hallucinationIssues);

    // 4. Calculate validation score
    const score = this.calculateValidationScore(issues);

    // 5. Generate recommendations
    const recommendations = this.generateRecommendations(issues);

    return {
      isValid: score >= 70 && !issues.some((i) => i.severity === 'critical'),
      score,
      issues,
      recommendations,
      validatedBy: 'themis',
      validatedAt: Date.now(),
    };
  }

  /**
   * Perform static analysis on test code
   * 
   * Fast, deterministic checks that don't require LLM.
   */
  private async performStaticAnalysis(test: GeneratedTest): Promise<TestIssue[]> {
    const issues: TestIssue[] = [];
    const code = test.code;

    // Check for syntax errors (basic)
    if (!this.hasValidSyntax(code)) {
      issues.push({
        type: 'syntax_error',
        severity: 'critical',
        description: 'Test code has syntax errors',
      });
    }

    // Check for assertions
    if (!this.hasAssertions(code)) {
      issues.push({
        type: 'no_assertion',
        severity: 'critical',
        description: 'Test has no assertions (expect/assert statements)',
      });
    }

    // Check for tautologies
    if (this.hasTautology(code)) {
      issues.push({
        type: 'tautology',
        severity: 'high',
        description: 'Test contains tautological assertions (always true)',
        suggestedFix: 'Replace with meaningful assertions that test actual behavior',
      });
    }

    // Check for potential flakiness
    if (this.hasPotentialFlakiness(code)) {
      issues.push({
        type: 'flaky',
        severity: 'medium',
        description: 'Test may be non-deterministic (uses Date.now(), Math.random(), etc.)',
        suggestedFix: 'Mock time/random functions or use deterministic values',
      });
    }

    return issues;
  }

  /**
   * Perform semantic validation using LLM
   * 
   * Independent LLM analysis to check if test makes sense.
   */
  private async performSemanticValidation(
    test: GeneratedTest,
    sourceCode: string
  ): Promise<TestIssue[]> {
    const prompt = this.buildSemanticValidationPrompt(test, sourceCode);

    try {
      const response = await this.runtimeEngine.execute({
        taskType: 'code_analysis',
        prompt,
        context: `You are Themis, an independent test validator. 
Your job is to critically analyze tests and find issues.
Be skeptical and thorough. Look for problems.`,
        maxTokens: 800,
      });

      return this.parseSemanticIssues(response.content);
    } catch (error) {
      console.warn('Semantic validation failed:', error);
      return [];
    }
  }

  /**
   * Detect hallucinations in test code
   * 
   * Critical check: Does the test reference non-existent functionality?
   */
  private async detectHallucinations(
    test: GeneratedTest,
    sourceCode: string
  ): Promise<TestIssue[]> {
    const issues: TestIssue[] = [];

    // Extract function/method calls from test
    const testCalls = this.extractFunctionCalls(test.code);

    // Extract available functions from source
    const sourceFunctions = this.extractFunctionDefinitions(sourceCode);

    // Check for hallucinated functions
    for (const call of testCalls) {
      // Skip test framework functions (expect, describe, it, etc.)
      if (this.isTestFrameworkFunction(call)) {
        continue;
      }

      // Check if function exists in source
      if (!sourceFunctions.includes(call) && !this.isStandardLibrary(call)) {
        issues.push({
          type: 'hallucination',
          severity: 'critical',
          description: `Test calls non-existent function: ${call}`,
          suggestedFix: `Remove or replace with actual function from source code`,
        });
      }
    }

    // Extract imports from test
    const testImports = this.extractImports(test.code);

    // Check for hallucinated imports
    for (const imp of testImports) {
      if (!this.isValidImport(imp, test.target.filePath)) {
        issues.push({
          type: 'import_error',
          severity: 'critical',
          description: `Test imports non-existent module: ${imp}`,
          suggestedFix: `Fix import path or remove if not needed`,
        });
      }
    }

    return issues;
  }

  /**
   * Calculate validation score based on issues
   */
  private calculateValidationScore(issues: TestIssue[]): number {
    let score = 100;

    for (const issue of issues) {
      switch (issue.severity) {
        case 'critical':
          score -= 30;
          break;
        case 'high':
          score -= 15;
          break;
        case 'medium':
          score -= 7;
          break;
        case 'low':
          score -= 3;
          break;
      }
    }

    return Math.max(0, score);
  }

  /**
   * Generate recommendations based on issues
   */
  private generateRecommendations(issues: TestIssue[]): string[] {
    const recommendations: string[] = [];

    const criticalIssues = issues.filter((i) => i.severity === 'critical');
    if (criticalIssues.length > 0) {
      recommendations.push(
        `❌ REJECT: ${criticalIssues.length} critical issue(s) found. Test must be rewritten.`
      );
    }

    const hallucinationIssues = issues.filter((i) => i.type === 'hallucination');
    if (hallucinationIssues.length > 0) {
      recommendations.push(
        `⚠️ HALLUCINATION DETECTED: Test references non-existent functionality. Verify against actual source code.`
      );
    }

    const highIssues = issues.filter((i) => i.severity === 'high');
    if (highIssues.length > 0) {
      recommendations.push(
        `⚠️ ${highIssues.length} high-severity issue(s). Consider rewriting test.`
      );
    }

    if (issues.length === 0) {
      recommendations.push('✅ Test passes all validation checks. Safe to use.');
    }

    return recommendations;
  }

  /**
   * Build semantic validation prompt
   */
  private buildSemanticValidationPrompt(
    test: GeneratedTest,
    sourceCode: string
  ): string {
    return `Analyze this test for semantic correctness and potential issues.

SOURCE CODE:
\`\`\`typescript
${sourceCode}
\`\`\`

GENERATED TEST:
\`\`\`typescript
${test.code}
\`\`\`

Check for:
1. Does the test actually test the function's behavior?
2. Are the assertions correct for the function's logic?
3. Are edge cases properly tested?
4. Is the test too broad or too narrow?
5. Does the test make logical sense?

Respond with issues found in this format:
ISSUE: [type]
SEVERITY: [critical/high/medium/low]
DESCRIPTION: [description]
---`;
  }

  /**
   * Parse semantic issues from LLM response
   */
  private parseSemanticIssues(response: string): TestIssue[] {
    const issues: TestIssue[] = [];
    const blocks = response.split('---').filter((b) => b.trim());

    for (const block of blocks) {
      const lines = block.split('\n').map((l) => l.trim());

      let type: string = 'wrong_assertion';
      let severity: TestIssueSeverity = 'medium';
      let description = '';

      for (const line of lines) {
        if (line.startsWith('ISSUE:')) {
          type = line.substring(6).trim();
        } else if (line.startsWith('SEVERITY:')) {
          const sev = line.substring(9).trim().toLowerCase();
          if (['critical', 'high', 'medium', 'low'].includes(sev)) {
            severity = sev as TestIssueSeverity;
          }
        } else if (line.startsWith('DESCRIPTION:')) {
          description = line.substring(12).trim();
        }
      }

      if (description) {
        issues.push({
          type: type as TestIssueType,
          severity,
          description,
        });
      }
    }

    return issues;
  }

  // Helper methods for static analysis

  private hasValidSyntax(code: string): boolean {
    // Basic syntax check - could be enhanced with actual parser
    const openBraces = (code.match(/{/g) || []).length;
    const closeBraces = (code.match(/}/g) || []).length;
    const openParens = (code.match(/\(/g) || []).length;
    const closeParens = (code.match(/\)/g) || []).length;

    return openBraces === closeBraces && openParens === closeParens;
  }

  private hasAssertions(code: string): boolean {
    return /expect\(|assert\(|should\./i.test(code);
  }

  private hasTautology(code: string): boolean {
    // Check for obvious tautologies
    return (
      /expect\(true\)\.toBe\(true\)/i.test(code) ||
      /expect\(false\)\.toBe\(false\)/i.test(code) ||
      /expect\(1\)\.toBe\(1\)/i.test(code)
    );
  }

  private hasPotentialFlakiness(code: string): boolean {
    return (
      /Date\.now\(\)|Math\.random\(\)|setTimeout|setInterval/i.test(code) &&
      !/mock|stub|fake/i.test(code)
    );
  }

  private extractFunctionCalls(code: string): string[] {
    // Simple regex to extract function calls
    const matches = code.match(/\b([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(/g) || [];
    return matches.map((m) => m.replace(/\s*\($/, ''));
  }

  private extractFunctionDefinitions(code: string): string[] {
    // Extract function names from source
    const matches =
      code.match(/(?:function|const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g) || [];
    return matches.map((m) => m.split(/\s+/)[1]).filter((s): s is string => s !== undefined);
  }

  private extractImports(code: string): string[] {
    const matches = code.match(/import\s+.*\s+from\s+['"]([^'"]+)['"]/g) || [];
    return matches.map((m) => {
      const match = m.match(/from\s+['"]([^'"]+)['"]/);
      return match ? match[1] : '';
    }).filter((s): s is string => s !== '');
  }

  private isTestFrameworkFunction(name: string): boolean {
    const frameworkFunctions = [
      'describe',
      'it',
      'test',
      'expect',
      'beforeEach',
      'afterEach',
      'beforeAll',
      'afterAll',
      'jest',
      'toBe',
      'toEqual',
      'toHaveLength',
      'toContain',
      'toThrow',
    ];
    return frameworkFunctions.includes(name);
  }

  private isStandardLibrary(name: string): boolean {
    const stdLib = [
      'console',
      'Math',
      'Date',
      'Array',
      'Object',
      'String',
      'Number',
      'Boolean',
      'Promise',
      'setTimeout',
      'setInterval',
      'JSON',
    ];
    return stdLib.includes(name);
  }

  private isValidImport(importPath: string, _targetPath: string): boolean {
    // Basic validation - could be enhanced with actual file system checks
    return (
      importPath.startsWith('.') || // Relative import
      importPath.startsWith('@') || // Scoped package
      !importPath.includes('/') // Node module
    );
  }
}

/**
 * Create a test validator instance
 * 
 * @param runtimeEngine - Runtime engine for LLM calls
 * @returns Test validator instance
 */
export function createTestValidator(runtimeEngine: RuntimeExecutor): TestValidator {
  return new TestValidator(runtimeEngine);
}
