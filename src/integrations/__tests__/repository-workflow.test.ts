/**
 * Unit tests for RepositoryWorkflow
 */

import { RepositoryWorkflow, WorkflowConfig, ChangeSet } from '../repository-workflow';
import { RepositoryProfile } from '../repository-connector';
import { exec } from 'child_process';

// Mock exec
jest.mock('child_process');
jest.mock('fs/promises');

describe('RepositoryWorkflow', () => {
  let config: WorkflowConfig;
  let profile: RepositoryProfile;

  beforeEach(() => {
    profile = {
      branchingStrategy: 'github-flow',
      mainBranch: 'main',
      featureBranchPrefix: 'feature/',
      testCommand: 'npm test',
      buildCommand: 'npm run build',
      lintCommand: 'npm run lint',
      reviewRequired: true,
      autoMerge: false,
    };

    config = {
      repoId: 'test-repo',
      repoPath: './test-repos/test-repo',
      provider: 'github',
      profile,
    };

    jest.clearAllMocks();
  });

  describe('constructor', () => {
    it('should create RepositoryWorkflow instance', () => {
      const workflow = new RepositoryWorkflow(config);
      expect(workflow).toBeInstanceOf(RepositoryWorkflow);
    });
  });

  describe('buildBranchName', () => {
    it('should build branch name with prefix', () => {
      const workflow = new RepositoryWorkflow(config);
      
      // Access private method through any
      const branchName = (workflow as any).buildBranchName('new-feature');
      
      expect(branchName).toBe('feature/new-feature');
    });

    it('should sanitize feature name', () => {
      const workflow = new RepositoryWorkflow(config);
      
      const branchName = (workflow as any).buildBranchName('New Feature With Spaces!');
      
      expect(branchName).toBe('feature/new-feature-with-spaces-');
    });

    it('should handle special characters', () => {
      const workflow = new RepositoryWorkflow(config);
      
      const branchName = (workflow as any).buildBranchName('feature@#$%name');
      
      expect(branchName).toBe('feature/feature----name');
    });

    it('should use default prefix if not specified', () => {
      const configWithoutPrefix = {
        ...config,
        profile: {
          ...profile,
          featureBranchPrefix: undefined,
        },
      };
      
      const workflow = new RepositoryWorkflow(configWithoutPrefix);
      const branchName = (workflow as any).buildBranchName('test');
      
      expect(branchName).toBe('feature/test');
    });
  });

  describe('enhancePRDescription', () => {
    it('should enhance PR description with stats', () => {
      const workflow = new RepositoryWorkflow(config);
      
      const enhanced = (workflow as any).enhancePRDescription(
        'Original description',
        5,
        { additions: 100, deletions: 50 },
        true,
        true
      );
      
      expect(enhanced).toContain('Original description');
      expect(enhanced).toContain('Files changed: 5');
      expect(enhanced).toContain('Lines added: +100');
      expect(enhanced).toContain('Lines removed: -50');
      expect(enhanced).toContain('✅ Passed');
      expect(enhanced).toContain('Generated by Prometheus');
    });

    it('should show failed tests', () => {
      const workflow = new RepositoryWorkflow(config);
      
      const enhanced = (workflow as any).enhancePRDescription(
        'Description',
        3,
        { additions: 50, deletions: 20 },
        true,
        false
      );
      
      expect(enhanced).toContain('❌ Failed');
    });

    it('should not show test status if tests not run', () => {
      const workflow = new RepositoryWorkflow(config);
      
      const enhanced = (workflow as any).enhancePRDescription(
        'Description',
        3,
        { additions: 50, deletions: 20 },
        false,
        false
      );
      
      expect(enhanced).not.toContain('Tests:');
    });
  });

  describe('runTests', () => {
    it('should return success when tests pass', async () => {
      const workflow = new RepositoryWorkflow(config);
      
      // Mock successful test execution
      const mockExec = require('child_process').exec as jest.Mock;
      mockExec.mockImplementation((cmd: string, options: any, callback: any) => {
        callback(null, { stdout: 'All tests passed', stderr: '' });
      });

      const result = await workflow.runTests();
      
      expect(result.passed).toBe(true);
      expect(result.command).toBe('npm test');
    });

    it('should return failure when tests fail', async () => {
      const workflow = new RepositoryWorkflow(config);
      
      // Mock failed test execution
      const mockExec = require('child_process').exec as jest.Mock;
      mockExec.mockImplementation((cmd: string, options: any, callback: any) => {
        const error: any = new Error('Tests failed');
        error.stdout = 'Test output';
        error.stderr = 'Error output';
        callback(error);
      });

      const result = await workflow.runTests();
      
      expect(result.passed).toBe(false);
      expect(result.output).toContain('Test output');
    });

    it('should skip tests if no test command configured', async () => {
      const configWithoutTests = {
        ...config,
        profile: {
          ...profile,
          testCommand: undefined,
        },
      };
      
      const workflow = new RepositoryWorkflow(configWithoutTests);
      const result = await workflow.runTests();
      
      expect(result.passed).toBe(true);
      expect(result.output).toContain('No test command configured');
    });
  });

  describe('runBuild', () => {
    it('should run build command', async () => {
      const workflow = new RepositoryWorkflow(config);
      
      const mockExec = require('child_process').exec as jest.Mock;
      mockExec.mockImplementation((cmd: string, options: any, callback: any) => {
        callback(null, { stdout: 'Build successful', stderr: '' });
      });

      const result = await workflow.runBuild();
      
      expect(result.passed).toBe(true);
      expect(result.command).toBe('npm run build');
    });

    it('should skip build if no build command configured', async () => {
      const configWithoutBuild = {
        ...config,
        profile: {
          ...profile,
          buildCommand: undefined,
        },
      };
      
      const workflow = new RepositoryWorkflow(configWithoutBuild);
      const result = await workflow.runBuild();
      
      expect(result.passed).toBe(true);
      expect(result.output).toContain('No build command configured');
    });
  });

  describe('runLint', () => {
    it('should run lint command', async () => {
      const workflow = new RepositoryWorkflow(config);
      
      const mockExec = require('child_process').exec as jest.Mock;
      mockExec.mockImplementation((cmd: string, options: any, callback: any) => {
        callback(null, { stdout: 'Lint passed', stderr: '' });
      });

      const result = await workflow.runLint();
      
      expect(result.passed).toBe(true);
      expect(result.command).toBe('npm run lint');
    });
  });

  describe('isWorkingDirectoryClean', () => {
    it('should return true for clean directory', async () => {
      const workflow = new RepositoryWorkflow(config);
      
      const mockExec = require('child_process').exec as jest.Mock;
      mockExec.mockImplementation((cmd: string, options: any, callback: any) => {
        callback(null, { stdout: '', stderr: '' });
      });

      const isClean = await workflow.isWorkingDirectoryClean();
      
      expect(isClean).toBe(true);
    });

    it('should return false for dirty directory', async () => {
      const workflow = new RepositoryWorkflow(config);
      
      const mockExec = require('child_process').exec as jest.Mock;
      mockExec.mockImplementation((cmd: string, options: any, callback: any) => {
        callback(null, { stdout: 'M file.ts\n', stderr: '' });
      });

      const isClean = await workflow.isWorkingDirectoryClean();
      
      expect(isClean).toBe(false);
    });
  });

  describe('branchExists', () => {
    it('should return true if branch exists', async () => {
      const workflow = new RepositoryWorkflow(config);
      
      const mockExec = require('child_process').exec as jest.Mock;
      mockExec.mockImplementation((cmd: string, options: any, callback: any) => {
        callback(null, { stdout: '  main\n  feature/test\n', stderr: '' });
      });

      const exists = await workflow.branchExists('feature/test');
      
      expect(exists).toBe(true);
    });

    it('should return false if branch does not exist', async () => {
      const workflow = new RepositoryWorkflow(config);
      
      const mockExec = require('child_process').exec as jest.Mock;
      mockExec.mockImplementation((cmd: string, options: any, callback: any) => {
        callback(null, { stdout: '  main\n', stderr: '' });
      });

      const exists = await workflow.branchExists('feature/nonexistent');
      
      expect(exists).toBe(false);
    });
  });

  describe('getCurrentBranch', () => {
    it('should return current branch name', async () => {
      const workflow = new RepositoryWorkflow(config);
      
      const mockExec = require('child_process').exec as jest.Mock;
      mockExec.mockImplementation((cmd: string, options: any, callback: any) => {
        callback(null, { stdout: 'feature/test\n', stderr: '' });
      });

      const branch = await workflow.getCurrentBranch();
      
      expect(branch).toBe('feature/test');
    });
  });

  describe('getCommitCount', () => {
    it('should return commit count between branches', async () => {
      const workflow = new RepositoryWorkflow(config);
      
      const mockExec = require('child_process').exec as jest.Mock;
      mockExec.mockImplementation((cmd: string, options: any, callback: any) => {
        callback(null, { stdout: '5\n', stderr: '' });
      });

      const count = await workflow.getCommitCount('main', 'feature/test');
      
      expect(count).toBe(5);
    });
  });
});
